
## Engine concepts/classes to maybe add

1. GameMode
    State machine:  loading, starting, running, stopping, stopped, unloading

## Gameplay logic

Games are implemented in two parts:

1. C++ modules implement gameplay systems.
    They operate on components, react to and emit events, can emit signals and accept signals through slots.
2. Gameplans are visual scripts that connect signals to slots.

    Gameplans are connected to the signal generator of a component:

        eg an entities TriggerRegion's on-enter signal has an attached Gameplan to handle when another entity enters that region.
    
    Signals can be processed before passing them to slots:

        Adapter nodes to change the signals types or format
        Filter nodes to only let signals with certain data through
        Transform nodes to modify a signal before passing it to a slot.

    Signals are generated by a system, for a source entity.

    Slots are part of the a system and tend to operate on a destination entity, usually to modify the 
    destination entities components in some way.

    Example:

        "Pressure Plate" entity has a TriggerRegion with an on-enter signal.
        "Door" entity has an open-door slot.
        A gameplan is attached to "Pressure Plate".TriggerRegion.on-enter and maps this signal to "Door".open-door
        Now, when a TriggerRegion aware entity enters the "Pressure Plate"'s region, the "Door" will open.

Perhaps add a "Choreographer" script: a textual scripting language to choreograph actions and emit events.

    Not sure if its needed yet. Might also be better as a visual timeline.
    It would have timing of events and actions to trigger and used to script interactions between characters (dialogue etc)
    Could this also be used to manage animation? Audio? Special effects? Bullet hell barrages?

## GamePlans

Attached to (or run by) a "signal". The signal defines what inputs the gameplan gets.

Gameplans output events and/or write to slots. Slots are defined by systems and owned by entities, that is, you write to "entity X's slot".

Gameplans can contain a certain amount of logic:

* Extracting data from the signal
* Filtering data
* Transforming data (basic math expressions and C++-defined functions)
* Sequence generators
* Timer/delays (note1)
* Combining data
* Generating events
* Interpolation and tweening
* Writing to slots

Should gameplans be able to read and write components? It would complicate the threading model and make execution harder (component defs need to be read to setup accessors) but it would mean component data could be animated through gameplans.

note1: Should gameplans run to completion when signals are triggered, or can they setup recurring/timed/delayed/multi-frame execution? This would be needed to make delays and timers possible as well as making gameplan-driven animation possible. A middleground might be that a gameplan could register a continuation to be executed when an internal signal is fired and schedule that signal to fire after a delay/on a timer/each frame/every N frames.


## Task List

1. implement a signal-slots system, add signals as a data type to components
1. expose slots as nodes in the visual scripting
1. make the "gameplan" node graphs be attached to component signals
1. implement nodes for adapters, filters and transformation of signals before passing them to slots
1. a runtime system for that which plays well with my task system
1. Wrap build setup, component generation and building in make so that you can do `make debug` or `make components`

## Renderer Notes


