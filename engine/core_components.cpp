// Autogenerated, do not edit!
#include <components/core.hpp>
#include <gou/api.hpp>
#include <toml.hpp>

using namespace entt::literals;

namespace gou {
	void register_components (gou::api::Engine* engine)
	{
		entt::registry& registry = engine->registry();
		entt::registry& prototype_registry = engine->prototypeRegistry();
		
		registry.prepare<components::Named>();
		prototype_registry.prepare<components::Named>();
		{
			gou::api::definitions::Component component {"named"_hs, "Named", entt::type_id<components::Named>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				registry.emplace_or_replace<components::Named>(entity, entt::hashed_string{toml::find<std::string>(table, "name").c_str()});
			};
			component.attributes.push_back({"name", gou::types::Type::HashedString, offsetof(components::Named, name)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::Named>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::Global>();
		prototype_registry.prepare<components::Global>();
		{
			gou::api::definitions::Component component {"global"_hs, "Global", entt::type_id<components::Global>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				registry.emplace_or_replace<components::Global>(entity);
			};
			component.getter = nullptr;
			engine->registerComponent(component);
		}
		
		registry.prepare<components::Transform>();
		prototype_registry.prepare<components::Transform>();
		{
			gou::api::definitions::Component component {"transform"_hs, "Transform", entt::type_id<components::Transform>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				auto rotation = table.at("rotation");
				auto scale = table.at("scale");
				registry.emplace_or_replace<components::Transform>(entity, glm::vec3{float(toml::find<toml::floating>(rotation, "x")), float(toml::find<toml::floating>(rotation, "y")), float(toml::find<toml::floating>(rotation, "z"))}, glm::vec3{float(toml::find<toml::floating>(scale, "x")), float(toml::find<toml::floating>(scale, "y")), float(toml::find<toml::floating>(scale, "z"))});
			};
			component.attributes.push_back({"rotation", gou::types::Type::Vec3, offsetof(components::Transform, rotation)});
			component.attributes.push_back({"scale", gou::types::Type::Vec3, offsetof(components::Transform, scale)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::Transform>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::Position>();
		prototype_registry.prepare<components::Position>();
		{
			gou::api::definitions::Component component {"position"_hs, "Position", entt::type_id<components::Position>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				registry.emplace_or_replace<components::Position>(entity, float(toml::find<toml::floating>(table, "x")), float(toml::find<toml::floating>(table, "y")), float(toml::find<toml::floating>(table, "z")));
			};
			component.attributes.push_back({"x", gou::types::Type::Float, offsetof(components::Position, x)});
			component.attributes.push_back({"y", gou::types::Type::Float, offsetof(components::Position, y)});
			component.attributes.push_back({"z", gou::types::Type::Float, offsetof(components::Position, z)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::Position>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::TriggerRegion>();
		prototype_registry.prepare<components::TriggerRegion>();
		{
			gou::api::definitions::Component component {"trigger-region"_hs, "TriggerRegion", entt::type_id<components::TriggerRegion>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				auto enter_event = table.at("enter-event");
				auto exit_event = table.at("exit-event");
				registry.emplace_or_replace<components::TriggerRegion>(entity, engine->findResource(entt::hashed_string::value(toml::find<std::string>(table, "shape").c_str())), gou::events::Event{entt::hashed_string::value(toml::find<std::string>(enter_event, "type").c_str()), entity, glm::vec3{float(toml::find<toml::floating>(enter_event, "x")), float(toml::find<toml::floating>(enter_event, "y")), float(toml::find<toml::floating>(enter_event, "z"))}}, gou::events::Event{entt::hashed_string::value(toml::find<std::string>(exit_event, "type").c_str()), entity, glm::vec3{float(toml::find<toml::floating>(exit_event, "x")), float(toml::find<toml::floating>(exit_event, "y")), float(toml::find<toml::floating>(exit_event, "z"))}}, engine->findSignal(entt::hashed_string::value(toml::find<std::string>(table, "on-enter").c_str())), engine->findSignal(entt::hashed_string::value(toml::find<std::string>(table, "on-exit").c_str())), std::uint32_t(toml::find<toml::integer>(table, "trigger-mask")));
			};
			component.attributes.push_back({"shape", gou::types::Type::Resource, offsetof(components::TriggerRegion, shape)});
			component.attributes.push_back({"enter-event", gou::types::Type::Event, offsetof(components::TriggerRegion, enter_event)});
			component.attributes.push_back({"exit-event", gou::types::Type::Event, offsetof(components::TriggerRegion, exit_event)});
			component.attributes.push_back({"on-enter", gou::types::Type::Signal, offsetof(components::TriggerRegion, on_enter)});
			component.attributes.push_back({"on-exit", gou::types::Type::Signal, offsetof(components::TriggerRegion, on_exit)});
			component.attributes.push_back({"trigger-mask", gou::types::Type::UInt32, offsetof(components::TriggerRegion, trigger_mask)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::TriggerRegion>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::TimeAware>();
		prototype_registry.prepare<components::TimeAware>();
		{
			gou::api::definitions::Component component {"time-aware"_hs, "TimeAware", entt::type_id<components::TimeAware>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				registry.emplace_or_replace<components::TimeAware>(entity, float(toml::find<toml::floating>(table, "scale-factor")));
			};
			component.attributes.push_back({"scale-factor", gou::types::Type::Float, offsetof(components::TimeAware, scale_factor)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::TimeAware>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::ScriptedBehavior>();
		prototype_registry.prepare<components::ScriptedBehavior>();
		{
			gou::api::definitions::Component component {"scripted-behavior"_hs, "ScriptedBehavior", entt::type_id<components::ScriptedBehavior>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				registry.emplace_or_replace<components::ScriptedBehavior>(entity, entt::hashed_string::value(toml::find<std::string>(table, "script").c_str()));
			};
			component.attributes.push_back({"script", gou::types::Type::Ref, offsetof(components::ScriptedBehavior, script)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::ScriptedBehavior>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::graphics::Layer>();
		prototype_registry.prepare<components::graphics::Layer>();
		{
			gou::api::definitions::Component component {"layer"_hs, "Layer", entt::type_id<components::graphics::Layer>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				registry.emplace_or_replace<components::graphics::Layer>(entity, std::uint8_t(toml::find<toml::integer>(table, "layer")));
			};
			component.attributes.push_back({"layer", gou::types::Type::UInt8, offsetof(components::graphics::Layer, layer)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::graphics::Layer>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::graphics::Sprite>();
		prototype_registry.prepare<components::graphics::Sprite>();
		{
			gou::api::definitions::Component component {"sprite"_hs, "Sprite", entt::type_id<components::graphics::Sprite>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				registry.emplace_or_replace<components::graphics::Sprite>(entity);
			};
			component.getter = nullptr;
			engine->registerComponent(component);
		}
		
		registry.prepare<components::graphics::Billboard>();
		prototype_registry.prepare<components::graphics::Billboard>();
		{
			gou::api::definitions::Component component {"billboard"_hs, "Billboard", entt::type_id<components::graphics::Billboard>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				registry.emplace_or_replace<components::graphics::Billboard>(entity, engine->findResource(entt::hashed_string::value(toml::find<std::string>(table, "image").c_str())));
			};
			component.attributes.push_back({"image", gou::types::Type::Resource, offsetof(components::graphics::Billboard, image)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::graphics::Billboard>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::graphics::Model>();
		prototype_registry.prepare<components::graphics::Model>();
		{
			gou::api::definitions::Component component {"model"_hs, "Model", entt::type_id<components::graphics::Model>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				registry.emplace_or_replace<components::graphics::Model>(entity, engine->findResource(entt::hashed_string::value(toml::find<std::string>(table, "mesh").c_str())), engine->findResource(entt::hashed_string::value(toml::find<std::string>(table, "material").c_str())));
			};
			component.attributes.push_back({"mesh", gou::types::Type::Resource, offsetof(components::graphics::Model, mesh)});
			component.attributes.push_back({"material", gou::types::Type::Resource, offsetof(components::graphics::Model, material)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::graphics::Model>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::graphics::PointLight>();
		prototype_registry.prepare<components::graphics::PointLight>();
		{
			gou::api::definitions::Component component {"point-light"_hs, "PointLight", entt::type_id<components::graphics::PointLight>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				auto color = table.at("color");
				registry.emplace_or_replace<components::graphics::PointLight>(entity, float(toml::find<toml::floating>(table, "radius")), glm::vec3{float(toml::find<toml::floating>(color, "x")), float(toml::find<toml::floating>(color, "y")), float(toml::find<toml::floating>(color, "z"))}, float(toml::find<toml::floating>(table, "intensity")));
			};
			component.attributes.push_back({"radius", gou::types::Type::Float, offsetof(components::graphics::PointLight, radius)});
			component.attributes.push_back({"color", gou::types::Type::Vec3, offsetof(components::graphics::PointLight, color)});
			component.attributes.push_back({"intensity", gou::types::Type::Float, offsetof(components::graphics::PointLight, intensity)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::graphics::PointLight>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::graphics::SpotLight>();
		prototype_registry.prepare<components::graphics::SpotLight>();
		{
			gou::api::definitions::Component component {"spot-light"_hs, "SpotLight", entt::type_id<components::graphics::SpotLight>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				auto color = table.at("color");
				auto direction = table.at("direction");
				registry.emplace_or_replace<components::graphics::SpotLight>(entity, float(toml::find<toml::floating>(table, "range")), glm::vec3{float(toml::find<toml::floating>(color, "x")), float(toml::find<toml::floating>(color, "y")), float(toml::find<toml::floating>(color, "z"))}, glm::vec3{float(toml::find<toml::floating>(direction, "x")), float(toml::find<toml::floating>(direction, "y")), float(toml::find<toml::floating>(direction, "z"))}, float(toml::find<toml::floating>(table, "intensity")));
			};
			component.attributes.push_back({"range", gou::types::Type::Float, offsetof(components::graphics::SpotLight, range)});
			component.attributes.push_back({"color", gou::types::Type::Vec3, offsetof(components::graphics::SpotLight, color)});
			component.attributes.push_back({"direction", gou::types::Type::Vec3, offsetof(components::graphics::SpotLight, direction)});
			component.attributes.push_back({"intensity", gou::types::Type::Float, offsetof(components::graphics::SpotLight, intensity)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::graphics::SpotLight>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::physics::StaticBody>();
		prototype_registry.prepare<components::physics::StaticBody>();
		{
			gou::api::definitions::Component component {"static-body"_hs, "StaticBody", entt::type_id<components::physics::StaticBody>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				registry.emplace_or_replace<components::physics::StaticBody>(entity, engine->findResource(entt::hashed_string::value(toml::find<std::string>(table, "shape").c_str())), nullptr);
			};
			component.attributes.push_back({"shape", gou::types::Type::Resource, offsetof(components::physics::StaticBody, shape)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::physics::StaticBody>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::physics::DynamicBody>();
		prototype_registry.prepare<components::physics::DynamicBody>();
		{
			gou::api::definitions::Component component {"dynamic-body"_hs, "DynamicBody", entt::type_id<components::physics::DynamicBody>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				registry.emplace_or_replace<components::physics::DynamicBody>(entity, engine->findResource(entt::hashed_string::value(toml::find<std::string>(table, "shape").c_str())), float(toml::find<toml::floating>(table, "mass")), nullptr);
			};
			component.attributes.push_back({"shape", gou::types::Type::Resource, offsetof(components::physics::DynamicBody, shape)});
			component.attributes.push_back({"mass", gou::types::Type::Float, offsetof(components::physics::DynamicBody, mass)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::physics::DynamicBody>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::physics::KinematicBody>();
		prototype_registry.prepare<components::physics::KinematicBody>();
		{
			gou::api::definitions::Component component {"kinematic-body"_hs, "KinematicBody", entt::type_id<components::physics::KinematicBody>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				registry.emplace_or_replace<components::physics::KinematicBody>(entity, engine->findResource(entt::hashed_string::value(toml::find<std::string>(table, "shape").c_str())), float(toml::find<toml::floating>(table, "mass")), nullptr);
			};
			component.attributes.push_back({"shape", gou::types::Type::Resource, offsetof(components::physics::KinematicBody, shape)});
			component.attributes.push_back({"mass", gou::types::Type::Float, offsetof(components::physics::KinematicBody, mass)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::physics::KinematicBody>(entity)); };
			engine->registerComponent(component);
		}
		
		registry.prepare<components::physics::CollisionSensor>();
		prototype_registry.prepare<components::physics::CollisionSensor>();
		{
			gou::api::definitions::Component component {"collision-sensor"_hs, "CollisionSensor", entt::type_id<components::physics::CollisionSensor>().seq()};
			component.loader = [](gou::api::Engine* engine, entt::registry& registry, const void* tableptr, entt::entity entity) {
				const auto& table = *reinterpret_cast<const toml::value*>(tableptr);
				registry.emplace_or_replace<components::physics::CollisionSensor>(entity, engine->findSignal(entt::hashed_string::value(toml::find<std::string>(table, "on-collision").c_str())));
			};
			component.attributes.push_back({"on-collision", gou::types::Type::Signal, offsetof(components::physics::CollisionSensor, on_collision)});
			component.getter = [](entt::registry& registry, entt::entity entity){ return (char*)&(registry.get<components::physics::CollisionSensor>(entity)); };
			engine->registerComponent(component);
		}
	}
} // gou::